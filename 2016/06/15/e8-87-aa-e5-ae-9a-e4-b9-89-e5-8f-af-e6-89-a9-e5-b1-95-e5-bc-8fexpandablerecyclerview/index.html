<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>自定义可扩展式ExpandableRecyclerVIew | Mango's blog</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">自定义可扩展式ExpandableRecyclerVIew</h1><a id="logo" href="/.">Mango's blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">自定义可扩展式ExpandableRecyclerVIew</h1><div class="post-meta">Jun 15, 2016<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span></div><a data-thread-key="2016/06/15/e8-87-aa-e5-ae-9a-e4-b9-89-e5-8f-af-e6-89-a9-e5-b1-95-e5-bc-8fexpandablerecyclerview/" href="/2016/06/15/e8-87-aa-e5-ae-9a-e4-b9-89-e5-8f-af-e6-89-a9-e5-b1-95-e5-bc-8fexpandablerecyclerview/#comments" class="ds-thread-count"></a><div class="post-content"><p><strong>RecyclerView</strong>是个万花筒，比起ListView好用很多，项目需要用到可扩展的列表用来显示每一项的更多信息，Github上这样的类库有很多，无非有两种形式，第一种是在点击一个Item的时候在该Item下方添加一个子布局并且添加动画，RecyclerView的刷新函数<span style="color: #ff6600;">notifyItemInserted(position)</span>自带默认的插入动画。第二种就是在点击一个Item的时发返回不同的<span style="color: #ff6600;">ItemViewType</span>，根据不同的<span style="color: #ff6600;">ItemViewType</span>加载不同的布局。本人是用的第二种方式实现的，有时间去亲自写一下第一种。</p>
<hr>
<p>1，首先我们要设计好折叠和扩展下的不同布局,具体布局由于分开了设计有好几个文件所以只是给出布局名字，收缩时的布局为<span style="color: #ff6600;">R.layout.alarm_list_item_collapsed</span>，扩展时的布局为<span style="color: #ff6600;">R.layout.alar_list_item_expanded</span> 。</p>
<p>2，接下来我们来到ViewHolder,由于折叠状态和展开状态有公共的业务逻辑，所以我写了一个ViewHolder抽象父类叫做AlarmViewHolder，下面是主要的核心代码，省略了部分业务逻辑:</p>
<p><pre class="lang:java decode:true">public abstract class AlarmViewHolder extends RecyclerView.ViewHolder {</pre></p>
<pre><code>public Alarm alarm;
//该控件为折叠展开都具有的控件
public ImageButton mArrow;

public AlarmViewHolder(View itemView) {
    super(itemView);
    mArrow = (ImageButton)itemView.findViewById(R.id.arrpw);
    //折叠展开公共控件事件
    setListeners();
}

public void setData(Alarm alarm){
    this.alarm =alarm;
}

public void clearData(){
    alarm =null;
}
//绑定alarm的信息到UI界面
public abstract void bindAlarm(Alarm alarm);
</code></pre><p>}<br>首先声明的是<span style="color: #ff6600;">Alarm </span>，这个类就是我们的Modle，在抽象父类里面传入alarm对象，并且将该对象传入抽象方法<span style="color: #ff6600;">bindAlarm </span>方法进行绑定该alarm对象的信息到UI界面，注意看<span style="color: #ff6600;">mArrow</span>这个控件，在父类里声明声明，在折叠状态和扩展装下有不同的点击事件，所以写在父类。</p>
<p>3，接下来继承上面的父类编写折叠状态时的ViewHolder:</p>
<p><pre class="lang:java decode:true ">/**</pre></p>
<ul>
<li><p>折叠状态的ViewHolder<br>*/<br>public class AlarmCollapsedViewHolder extends AlarmViewHolder {</p>
<p> private final AlarmAdapter mAlarmAdapter;<br> private final Context mContext;</p>
<p> public AlarmCollapsedViewHolder(View itemView, AlarmAdapter alarmAdapter) {</p>
<pre><code>super(itemView, alarmClickHandler);
mContext = itemView.getContext();
mAlarmAdapter = alarmAdapter;
//扩展
mArrow.setOnClickListener(v -&amp;gt; {
    mAlarmAdapter.expand(getAdapterPosition());
});
setListeners();
</code></pre><p> }<br> @Override<br> public void bindAlarm(Alarm alarm) {</p>
<pre><code>setData(alarm);
//在此绑定响应数据
</code></pre><p> }<br>}<br>先提前说下后面会提到的<span style="color: #ff6600;">AlarmAdapter</span>，Adapter里包涵有扩展和折叠的方法，在这里用到了里面的<span style="color: #ff6600;">expand<span style="color: #000000;">方法就是扩展的方法。<span style="color: #ff6600;">AlarmCollapsedViewHolder<span style="color: #000000;">继承AlarmViewHolder实现bindAlarm方法进行绑定alarm数据到UI界面，公共控件（应该说是同一个id）mArrow在这里是可以触发扩展事件。</span></span></span></span></p>
</li>
</ul>
<p>4，下面该实现扩展的ViewHolder了，跟折叠的ViewHolder差不多:</p>
<p><pre class="lang:java decode:true">public class AlarmExpandedViewHolder extends AlarmViewHolder {</pre></p>
<pre><code>private final AlarmAdapter mAlarmAdapter;
private final Context mContext;

public AlarmExpandedViewHolder(View itemView, AlarmAdapter alarmAdapter) {
    super(itemView, alarmClickHandler);
    mContext = itemView.getContext();
    mAlarmAdapter = alarmAdapter;
     //折叠Edit
    mArrow.setOnClickListener(v -&amp;gt; mAlarmAdapter.collapse(getAdapterPosition()));
}

@Override
public void bindAlarm(Alarm alarm) {
    setData(alarm);

}
</code></pre><p>}<br>与折叠ViewHolder的唯一区别就在于<span style="color: #ff6600;">mArrow<span style="color: #000000;">的点击事件触发的是收缩事件。</span></span></p>
<p>5，为了展开之后能够使item定位到合适的位置定义一个接口</p>
<p><pre class="lang:java decode:true ">public interface IRecyclerViewScroll {</pre></p>
<pre><code>/**
 *设置滚动到相应item的Id
 */
void setSmoothScrollStableId(String stableId);

/**
 * 滚动到对应的位置
 */
void smoothScrollTo(int position);
</code></pre><p>}<br><br>6，到这里就该写上面提到的AlarmAdaper了：</p>
<p><pre class="lang:java decode:true ">public class AlarmAdapter extends RecyclerView.Adapter&lt;AlarmViewHolder&gt; {</pre></p>
<pre><code>private static final int VIEW_TYPE_ALARM_COLLAPSED = R.layout.alarm_list_item_collapsed;
private static final int VIEW_TYPE_ALARM_EXPANDED = R.layout.alarm_list_item_expanded;

private int mExpandedPosition = -1;
private String mExpandedId = Alarm.INVALID_ID;
private IRecyclerViewScroll mIRecyclerViewScroll;
private Context mContext;
private List&amp;lt;Alarm&amp;gt; mList = new ArrayList&amp;lt;&amp;gt;();

public AlarmAdapter(Context context, IRecyclerViewScroll iRecyclerViewScroll) {
    mIRecyclerViewScroll = iRecyclerViewScroll;
    mContext = context;
    setHasStableIds(true);
}

@Override
public AlarmViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
    View view = LayoutInflater.from(mContext).inflate(viewType, parent, false);
    if (viewType == VIEW_TYPE_ALARM_COLLAPSED) {
        return new AlarmCollapsedViewHolder(view, this, mAlarmClickHandler);
    } else {
        return new AlarmExpandedViewHolder(view, this, mAlarmClickHandler, mAlarmUpdateHandler);
    }
}

@Override
public void onBindViewHolder(AlarmViewHolder holder, int position) {
    Alarm alarm = mList.get(position);
    holder.bindAlarm(alarm);
}

@Override
public void onViewRecycled(AlarmViewHolder holder) {
    super.onViewRecycled(holder);
    holder.clearData();
}

/**
 * 避免notifyDataSetChanged()之后相同位置返回不同的对象，导致notifyDataSetChanged()
 * 之后视图刷新不稳定，出现闪烁。
 * 由于主键为UUID，所以取整型的hashCode作为UUID的代替唯一标识
 *
 * @param position
 * @return
 */
@Override
public long getItemId(int position) {
    //此处返回对应的AlarmId,主要用于对比滑动Id
    Alarm alarm = mList.get(position);
    if (alarm == null) {
        return RecyclerView.NO_ID;
    }
    UUID uuid = UUID.fromString(alarm.getId());
    return uuid.hashCode();
}

/**
 * 返回Item的Id也即UUID
 *
 * @param position
 * @return
 */
public String getItemUUID(int position) {
    //此处返回对应的AlarmId,主要用于对比滑动Id
    Alarm alarm = mList.get(position);
    if (alarm == null) {
        return &quot;-1&quot;;
    }
    return alarm.getId();
}

@Override
public int getItemCount() {
    return mList.size();
}

@Override
public int getItemViewType(int position) {
    //将布局当作viewtype
    final String stableId = getItemUUID(position);
    return stableId != String.valueOf(RecyclerView.NO_ID) &amp;amp;&amp;amp; stableId.equals(mExpandedId)
            ? VIEW_TYPE_ALARM_EXPANDED : VIEW_TYPE_ALARM_COLLAPSED;

}

/**
 * 扩展并且滑动到这个item
 */
public void expand(int position) {
    final String stableId = getItemUUID(position);
    //当前Id和扩展Id一样无须再次扩展
    if (mExpandedId.equals(stableId)) {
        return;
    }
    mExpandedId = stableId;
    mIRecyclerViewScroll.smoothScrollTo(position);
    if (mExpandedPosition &amp;gt;= 0) {
        notifyItemChanged(mExpandedPosition);
    }
    mExpandedPosition = position;
    notifyItemChanged(position);
}

//收缩
public void collapse(int position) {
    mExpandedId = Alarm.INVALID_ID;
    mExpandedPosition = -1;
    notifyItemChanged(position);
}

//更新数据
public void setData(List&amp;lt;Alarm&amp;gt; list) {
    if (list != null) {
        mList.clear();
        mList.addAll(list);
    }
    notifyDataSetChanged();
}

public String getmExpandedId() {
    return mExpandedId;
}

public void setmExpandedId(String mExpandedId) {
    this.mExpandedId = mExpandedId;
}
</code></pre><p>}<br>这个类的内容比较多，只是贴上了核心代码，整体逻辑还是比较清晰的。先声明该项目的数据库主键使用的字符串类型的UUID，所以重写<span style="color: #ff6600;">getItemId</span>的时候返回的是UUID的Hash值（数据库为整型的话直接返回数据库Id就行了），此方法必须重写而且返回唯一值，并且需要声明<span style="color: #ff6600;">setHasStableId(true)</span>，主要是为了给每一个Item一个唯一Id,这样在扩展的时候不容易乱掉。</p>
<p>接下来我们在<span style="color: #ff6600;">getViewType</span>里根据不同条件返回不同的布局，返回扩展布局的条件是<span style="color: #ff0000;">当前id不等于RecyclerView的默认空Id并且当前Id要等于mExpandId<span style="color: #000000;">，我们可以看到在<span style="color: #ff6600;">expand</span>方法里我们对<span style="color: #ff0000;">mExpandId</span>进行的对比和赋值然后刷新布局，在<span style="color: #ff6600;">collapse</span>方法里讲<span style="color: #ff0000;">mExpandId设置为初始值（-1）<span style="color: #000000;">,这样就可以达到折叠效果。</span></span></span></span></p>
<p>应该可以注意到在<span style="color: #ff6600;">expand</span>方法里调用了<span style="color: #ff6600;">IRecyclerViewScroll</span>接口的<span style="color: #ff6600;">smoothScroll</span>方法，为什么要在这里调用它，看下这个函数的意思就知道，我们会在他的回调方法里去定位到扩展Item。</p>
<p>7，在用到RecyclerView的Activityg或者Fragment里</p>
<p><pre class="lang:java decode:true">public class AlarmListFragment extends Fragment implements IRecyclerViewScroll,<br>        LoaderManager.LoaderCallbacks&lt;List&lt;Alarm&gt;&gt;{</pre></p>
<pre><code>public static final String EXTRA_SCROLL_TO_ALARM = &quot;extrascroll_to_alarm&quot;;

private RecyclerView mRecyclerView;
private AlarmAdapter mAlarmAdapter;
private String mScrollId;
private String mExpandId = Alarm.INVALID_ID;
private Loader mLoader;
//与Activity交互接口
private IAlarmListFragmentListener mListener;

public AlarmListFragment() {
}

@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setHasOptionsMenu(true);
    //初始化loader
    mLoader = getLoaderManager().initLoader(0, null, this);

}

@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container,
                         Bundle savedInstanceState) {
    return inflater.inflate(R.layout.fragment_alarm_list, container, false);
}

@Override
public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
    super.onViewCreated(view, savedInstanceState);
    Toolbar toolbar = (Toolbar) view.findViewById(R.id.toolbar);
    ((AppCompatActivity) getActivity()).setSupportActionBar(toolbar);
    mLinearLayoutManager = new LinearLayoutManager(getActivity());
    initViewValue();
}

@Override
public void onResume() {
    super.onResume();
    final Intent intent = getActivity().getIntent();
    if (intent.hasExtra(EXTRA_SCROLL_TO_ALARM)) {
        String alarmId = intent.getStringExtra(Alarm.EXTRA_ALARM_ID);
        if (!TextUtils.isEmpty(alarmId) &amp;amp;&amp;amp; !alarmId.equals(Alarm.INVALID_ID)) {
            setSmoothScrollStableId(alarmId);
            mLoader.forceLoad();
        }
    }
}

private void initViewValue() {
    mScrollId = Alarm.INVALID_ID;
    mRecyclerView.setLayoutManager(mLinearLayoutManager);
    mAlarmAdapter.setmExpandedId(mExpandId);
    mRecyclerView.setAdapter(mAlarmAdapter);
}

@Override
public void onAttach(Context context) {
    super.onAttach(context);
    if (context instanceof IAlarmListFragmentListener) {
        mListener = (IAlarmListFragmentListener) context;
    }
}

@Override
public Loader&amp;lt;List&amp;lt;Alarm&amp;gt;&amp;gt; onCreateLoader(int id, Bundle args) {
    Log.d(TAG, &quot;onCreateLoader: &quot;);
    return new AlarmAsyncTaskLoader(getActivity());
}

@Override
public void onLoadFinished(Loader&amp;lt;List&amp;lt;Alarm&amp;gt;&amp;gt; loader, List&amp;lt;Alarm&amp;gt; data) {
    Log.d(TAG, &quot;onLoadFinished: &quot;);
    mAlarmAdapter.setData(data);
    if (!mScrollId.equals(Alarm.INVALID_ID)) {
        scrollToPosition();
        setSmoothScrollStableId(Alarm.INVALID_ID);
    }

}

/**
 * 更新数据之后滑动
 */
private void scrollToPosition() {
    int alarmCount = mAlarmAdapter.getItemCount();
    for (int position = 0; position &amp;lt; alarmCount; position++) {
        if (mScrollId.equals(mAlarmAdapter.getItemUUID(position))) {
            mAlarmAdapter.expand(position);
            break;
        }
    }
}

@Override
public void onLoaderReset(Loader&amp;lt;List&amp;lt;Alarm&amp;gt;&amp;gt; loader) {
    mAlarmAdapter.setData(null);
}

@Override
public void setSmoothScrollStableId(String stableId) {
    mScrollId = stableId;
}

@Override
public void smoothScrollTo(int position) {

    mLinearLayoutManager.scrollToPositionWithOffset(position, 20);
}
</code></pre><p>}<br><br>在这个Fragment里 我使用的<span style="color: #ff6600;">AsyncTaskLoader</span>加载数据，在<span style="color: #ff6600;">onLoadFinish</span>里调用了<span style="color: #ff6600;">setSmoothScrollStableId(Alarm.INVALID_ID)</span>方法进行初始化设置，加载完成是不会扩展的，注意下<span style="color: #ff6600;">onResume</span>里我们也调用了<span style="color: #ff6600;">setSmoothScrollStableId(alarmId)</span>，其实在第一次打开APP的时候<span style="color: #ff6600;">alarmId</span>是空的所以不会扩展，但是在这里调用的目的可以根据<span style="color: #ff6600;">Intent</span>看到是别的页面跳转过来，指定闹钟扩展。</p>
<p><span style="color: #000000;">接下来看前面提到的<span style="color: #ff6600;">smoothScrollTo<span style="color: #000000;">，我们在这里执行了<span style="color: #ff6600;">mLinearLayoutManager.scrollToPositionWithOffest(position,20)</span>,这里我们用这个方法跳到指定的Item。</span></span></span></p>
<p>这样RecyclerView就实现了完美的扩展。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://zysidea.com/2016/06/15/e8-87-aa-e5-ae-9a-e4-b9-89-e5-8f-af-e6-89-a9-e5-b1-95-e5-bc-8fexpandablerecyclerview/" data-id="ciu8dp48r000i2ks680u9y0ux" class="article-share-link">分享到</a><div class="tags"></div><div class="post-nav"><a href="/2016/05/30/e5-88-9d-e6-b6-89go-e8-af-ad-e8-a8-80-e5-ae-9e-e7-8e-b0-e6-96-90-e6-b3-a2-e7-ba-b3-e5-a5-91-e6-95-b0/" class="next">初涉Go实现斐波纳契数</a></div><div data-thread-key="2016/06/15/e8-87-aa-e5-ae-9a-e4-b9-89-e5-8f-af-e6-89-a9-e5-b1-95-e5-bc-8fexpandablerecyclerview/" data-title="自定义可扩展式ExpandableRecyclerVIew" data-url="http://zysidea.com/2016/06/15/e8-87-aa-e5-ae-9a-e4-b9-89-e5-8f-af-e6-89-a9-e5-b1-95-e5-bc-8fexpandablerecyclerview/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/06/15/e8-87-aa-e5-ae-9a-e4-b9-89-e5-8f-af-e6-89-a9-e5-b1-95-e5-bc-8fexpandablerecyclerview/" data-title="自定义可扩展式ExpandableRecyclerVIew" data-url="http://zysidea.com/2016/06/15/e8-87-aa-e5-ae-9a-e4-b9-89-e5-8f-af-e6-89-a9-e5-b1-95-e5-bc-8fexpandablerecyclerview/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/">Golang</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/SQLite/" style="font-size: 15px;">SQLite</a> <a href="/tags/Golang/" style="font-size: 15px;">Golang</a> <a href="/tags/EditText/" style="font-size: 15px;">EditText</a> <a href="/tags/TextWatcher/" style="font-size: 15px;">TextWatcher</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/06/15/e8-87-aa-e5-ae-9a-e4-b9-89-e5-8f-af-e6-89-a9-e5-b1-95-e5-bc-8fexpandablerecyclerview/">自定义可扩展式ExpandableRecyclerVIew</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/30/e5-88-9d-e6-b6-89go-e8-af-ad-e8-a8-80-e5-ae-9e-e7-8e-b0-e6-96-90-e6-b3-a2-e7-ba-b3-e5-a5-91-e6-95-b0/">初涉Go实现斐波纳契数</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/09/android-e6-95-b0-e6-8d-ae-e5-ba-93-e6-96-b9-e6-b3-95-e5-b0-81-e8-a3-85/">Android数据库方法封装</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/15/android-e5-bc-80-e5-8f-91-e7-8e-af-e5-a2-83-e6-90-ad-e5-bb-ba/">Android开发环境搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/06/e5-8c-ba-e5-88-86edittext-e6-98-af-e4-bb-a3-e7-a0-81-e8-b5-8b-e5-80-bc-e8-bf-98-e6-98-af-e6-89-8b-e5-8a-a8-e8-be-93-e5-85-a5-e8-b5-8b-e5-80-bc/">区分EditText是代码赋值还是手动输入赋值</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/10/e5-85-b3-e4-ba-8eandroid-e9-bb-91-e5-b1-8f-e5-be-85-e6-9c-ba-e4-b9-8b-e5-90-8e-e4-bf-9d-e6-8c-81cpu-e8-bf-90-e4-bd-9c-e6-89-a7-e8-a1-8c-e4-bb-bb-e5-8a-a1/">关于Android黑屏待机之后保持CPU运作执行任务</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/01/e4-b8-barecyclerview-e6-b7-bb-e5-8a-a0itemclick/">为RecyclerView添加ItemClick</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Mango's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'zysidea'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?bd2e33fbddecfa049a8e561d59618de1";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>